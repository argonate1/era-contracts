// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IGhostVerifier} from "../interfaces/IGhostContracts.sol";
import {RedeemVerifier} from "./RedeemVerifier.sol";
import {PartialRedeemVerifier} from "./PartialRedeemVerifier.sol";

/**
 * @title ProductionVerifier
 * @notice Production ZK proof verifier for Ghost Protocol
 * @dev This contract wraps the snarkjs-generated Groth16 verifiers for
 *      full and partial redemption circuits.
 *
 * The Groth16 verifier uses the following structure:
 * - Proof: (a, b, c) where a,c are G1 points and b is a G2 point
 * - Public inputs: Array of field elements
 *
 * For the redeem circuit (6 public signals):
 * - [0] output: commitment validation flag
 * - [1] merkleRoot
 * - [2] nullifier
 * - [3] amount
 * - [4] tokenAddress
 * - [5] recipient
 *
 * For the partial redeem circuit (10 public signals):
 * - [0] newNullifierHash (output)
 * - [1] newCommitment (output)
 * - [2] valid (output flag)
 * - [3] merkleRoot
 * - [4] oldNullifierHash
 * - [5] redeemAmount
 * - [6] remainingAmount
 * - [7] tokenAddress
 * - [8] recipient
 * - [9] currentTimestamp
 */
contract ProductionVerifier is IGhostVerifier {
    /// @notice BN254 scalar field size - all public inputs must be < this value
    uint256 public constant SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    /// @notice Deployed redeem circuit verifier (generated by snarkjs)
    RedeemVerifier public immutable redeemVerifier;

    /// @notice Deployed partial redeem circuit verifier (generated by snarkjs)
    PartialRedeemVerifier public immutable partialRedeemVerifier;

    /// @notice Owner for administrative functions
    address public owner;

    // Errors
    error Unauthorized();
    error ZeroAddress();
    error InvalidProofLength();
    error InvalidInputLength();
    error InputOutOfField();
    error VerificationFailed();
    error ProofDecodingFailed();

    // Events
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized();
        _;
    }

    /**
     * @notice Deploy the production verifier with embedded Groth16 verifiers
     * @dev Deploys fresh instances of RedeemVerifier and PartialRedeemVerifier
     */
    constructor() {
        owner = msg.sender;
        redeemVerifier = new RedeemVerifier();
        partialRedeemVerifier = new PartialRedeemVerifier();
    }

    /**
     * @inheritdoc IGhostVerifier
     * @notice Verify a full redemption proof
     * @dev Public inputs must be exactly 6 elements in circuit order:
     *      [output, merkleRoot, nullifier, amount, tokenAddress, recipient]
     * @param proof The encoded Groth16 proof (pA, pB, pC)
     * @param publicInputs The 6 public inputs matching circuit ordering
     * @return True if the proof is valid
     */
    function verifyRedemptionProof(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external view override returns (bool) {
        // Verify public inputs length (6 signals for redeem circuit)
        if (publicInputs.length != 6) revert InvalidInputLength();

        // Validate all inputs are within the scalar field
        _validateInputsInField(publicInputs);

        // Validate proof length (256 bytes for Groth16)
        if (proof.length < 256) revert InvalidProofLength();

        // Decode proof components
        (
            uint256[2] memory pA,
            uint256[2][2] memory pB,
            uint256[2] memory pC
        ) = _decodeProof(proof);

        // Convert dynamic array to fixed-size array for verifier
        uint256[6] memory pubSignals;
        for (uint256 i = 0; i < 6; i++) {
            pubSignals[i] = publicInputs[i];
        }

        // Call the Groth16 verifier
        return redeemVerifier.verifyProof(pA, pB, pC, pubSignals);
    }

    /**
     * @inheritdoc IGhostVerifier
     * @notice Verify a partial redemption proof
     * @dev Public inputs must be exactly 10 elements in circuit order:
     *      [newNullifierHash, newCommitment, valid, merkleRoot, oldNullifierHash,
     *       redeemAmount, remainingAmount, tokenAddress, recipient, currentTimestamp]
     * @param proof The encoded Groth16 proof (pA, pB, pC)
     * @param publicInputs The 10 public inputs matching circuit ordering
     * @return True if the proof is valid
     */
    function verifyPartialRedemptionProof(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external view override returns (bool) {
        // Verify public inputs length (10 signals for partial redeem circuit)
        if (publicInputs.length != 10) revert InvalidInputLength();

        // Validate all inputs are within the scalar field
        _validateInputsInField(publicInputs);

        // Validate proof length (256 bytes for Groth16)
        if (proof.length < 256) revert InvalidProofLength();

        // Decode proof components
        (
            uint256[2] memory pA,
            uint256[2][2] memory pB,
            uint256[2] memory pC
        ) = _decodeProof(proof);

        // Convert dynamic array to fixed-size array for verifier
        uint256[10] memory pubSignals;
        for (uint256 i = 0; i < 10; i++) {
            pubSignals[i] = publicInputs[i];
        }

        // Call the Groth16 verifier
        return partialRedeemVerifier.verifyProof(pA, pB, pC, pubSignals);
    }

    /**
     * @notice Validate that all public inputs are within the BN254 scalar field
     * @param inputs The public inputs to validate
     */
    function _validateInputsInField(uint256[] calldata inputs) internal pure {
        for (uint256 i = 0; i < inputs.length; i++) {
            if (inputs[i] >= SCALAR_FIELD) revert InputOutOfField();
        }
    }

    /**
     * @notice Decode a Groth16 proof from bytes
     * @dev Expected format: abi.encode(uint256[2] pA, uint256[2][2] pB, uint256[2] pC)
     * @param proof The encoded proof bytes (256 bytes)
     * @return pA The G1 point A
     * @return pB The G2 point B
     * @return pC The G1 point C
     */
    function _decodeProof(bytes calldata proof)
        internal
        pure
        returns (
            uint256[2] memory pA,
            uint256[2][2] memory pB,
            uint256[2] memory pC
        )
    {
        // Decode the proof components from ABI-encoded bytes
        // pA: bytes 0-63 (2 uint256s)
        // pB: bytes 64-191 (4 uint256s in 2x2 array)
        // pC: bytes 192-255 (2 uint256s)
        (pA, pB, pC) = abi.decode(proof, (uint256[2], uint256[2][2], uint256[2]));
    }

    /**
     * @notice Transfer ownership of the contract
     * @param newOwner The new owner address
     */
    function transferOwnership(address newOwner) external onlyOwner {
        if (newOwner == address(0)) revert ZeroAddress();
        address oldOwner = owner;
        owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}
