// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {Test, console2} from "forge-std/Test.sol";
import {ProductionVerifier} from "../../../contracts/ghost/verifiers/ProductionVerifier.sol";

/**
 * @title ZkRealE2E
 * @notice End-to-end tests for Ghost Protocol ZK proof verification using real Groth16 proofs
 * @dev Tests use pre-generated proofs from the SDK to verify on-chain verifiers work correctly
 *
 * The proofs are generated by: scripts/ghost/generateTestProofs.ts
 * The fixture is stored at: test/foundry/ghost/fixtures/real_proof_data.json
 *
 * Public signal ordering (from snarkjs, outputs first):
 *
 * Redeem circuit (6 signals):
 *   [0] commitmentOut - the computed commitment (output)
 *   [1] merkleRoot - root of the Merkle tree
 *   [2] nullifier - to prevent double-spending
 *   [3] amount - amount being redeemed
 *   [4] tokenAddress - address of the token contract
 *   [5] recipient - address receiving the tokens
 *
 * Partial Redeem circuit (10 signals):
 *   [0] oldCommitmentOut - computed old commitment (output)
 *   [1] newCommitmentOut - computed new commitment (output)
 *   [2] remainingAmountOut - remaining amount (output)
 *   [3] merkleRoot - root of the Merkle tree
 *   [4] oldNullifier - nullifier of original commitment
 *   [5] redeemAmount - amount being redeemed now
 *   [6] tokenAddress - address of the token contract
 *   [7] recipient - address receiving the tokens
 *   [8] originalAmount - original amount in commitment
 *   [9] newCommitment - new commitment for change
 */
contract ZkRealE2E is Test {
    // BN254 scalar field - all public inputs must be < this value
    uint256 constant SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    ProductionVerifier public verifier;

    // Hardcoded test data from real_proof_data.json
    // Redeem proof data
    bytes constant REDEEM_PROOF = hex"2811a2b3aa1756cb1dc97c466c2da4277c3aaac82481ee375e4fd421bffa8e47065c2f8c25be2688e2ce71d37b72395d31f77769534670a76b7ee274e9f94680256a95954952724ea8f89bcaf1b6030fc709a59bd49b59d0a087796bf7c1198d0ddda2d2771f6e887508e114aec2d3d677670be98934901f41a0ce6c6e2e09cf07c8aed95fdae30368c009b990ef0fca8dfafeb903b897b12db0c329d7d009b91256f5107a59ea68fe64a5e45a5cd993a70a2f4172b9507ddd874ff4d2a11e6f07ee133d156eab88011d104c8792fc498cc0c10efbcc892d1cb16f61fe57766d06729c05c6fae03940297dc66d40f8a3ce3330b27d196a904ef8931042df52f0";

    // Public signals for redeem (6 signals in snarkjs order: outputs first, then inputs)
    uint256 constant REDEEM_COMMITMENT_OUT = 8060619959719976806037957960745680355834567095386014458614544030272213431086;
    uint256 constant REDEEM_MERKLE_ROOT = 6344709907042855164863352970459666665944803524885807336855274774503392156352;
    uint256 constant REDEEM_NULLIFIER = 17368957730408563057452664931448697231267280927965043590323638950290894112300;
    uint256 constant REDEEM_AMOUNT = 1000000000000000000; // 1 token
    uint256 constant REDEEM_TOKEN_ADDRESS = 546584486846459126461364135121053344201067465379;
    uint256 constant REDEEM_RECIPIENT = 1390849295786071768276380950238675083608645509734;

    function setUp() public {
        // Deploy the production verifier with real Groth16 verifiers
        verifier = new ProductionVerifier();
    }

    // =========================================================================
    // REDEEM PROOF TESTS
    // =========================================================================

    /**
     * @notice Test that public signals are within the scalar field
     */
    function test_RedeemSignalsWithinField() public pure {
        assertLt(REDEEM_COMMITMENT_OUT, SCALAR_FIELD, "commitmentOut >= SCALAR_FIELD");
        assertLt(REDEEM_MERKLE_ROOT, SCALAR_FIELD, "merkleRoot >= SCALAR_FIELD");
        assertLt(REDEEM_NULLIFIER, SCALAR_FIELD, "nullifier >= SCALAR_FIELD");
        assertLt(REDEEM_AMOUNT, SCALAR_FIELD, "amount >= SCALAR_FIELD");
        assertLt(REDEEM_TOKEN_ADDRESS, SCALAR_FIELD, "tokenAddress >= SCALAR_FIELD");
        assertLt(REDEEM_RECIPIENT, SCALAR_FIELD, "recipient >= SCALAR_FIELD");
    }

    /**
     * @notice Test that redeem proof has correct number of public signals (6)
     */
    function test_RedeemPublicSignalCount() public pure {
        // Verify we have exactly 6 public signals
        uint256[] memory signals = new uint256[](6);
        signals[0] = REDEEM_COMMITMENT_OUT;
        signals[1] = REDEEM_MERKLE_ROOT;
        signals[2] = REDEEM_NULLIFIER;
        signals[3] = REDEEM_AMOUNT;
        signals[4] = REDEEM_TOKEN_ADDRESS;
        signals[5] = REDEEM_RECIPIENT;

        assertEq(signals.length, 6, "Expected 6 public signals for redeem");
    }

    /**
     * @notice Test that real redeem Groth16 proof verifies successfully
     */
    function test_RedeemProofVerification() public {
        uint256[] memory publicInputs = new uint256[](6);
        publicInputs[0] = REDEEM_COMMITMENT_OUT;
        publicInputs[1] = REDEEM_MERKLE_ROOT;
        publicInputs[2] = REDEEM_NULLIFIER;
        publicInputs[3] = REDEEM_AMOUNT;
        publicInputs[4] = REDEEM_TOKEN_ADDRESS;
        publicInputs[5] = REDEEM_RECIPIENT;

        console2.log("Testing redeem proof verification...");
        console2.log("  Proof length:", REDEEM_PROOF.length);
        console2.log("  Public signals:", publicInputs.length);

        bool result = verifier.verifyRedemptionProof(REDEEM_PROOF, publicInputs);
        assertTrue(result, "Redeem proof verification failed");
    }

    /**
     * @notice Test that modifying any public signal causes verification to fail
     */
    function test_RedeemProofFailsWithWrongSignals() public {
        uint256[] memory publicInputs = new uint256[](6);
        publicInputs[0] = REDEEM_COMMITMENT_OUT;
        publicInputs[1] = REDEEM_MERKLE_ROOT;
        publicInputs[2] = REDEEM_NULLIFIER;
        publicInputs[3] = REDEEM_AMOUNT;
        publicInputs[4] = REDEEM_TOKEN_ADDRESS;
        publicInputs[5] = REDEEM_RECIPIENT;

        // Verify original proof works
        assertTrue(verifier.verifyRedemptionProof(REDEEM_PROOF, publicInputs), "Original proof should verify");

        // Modify each signal and verify failure
        for (uint256 i = 0; i < 6; i++) {
            uint256[] memory modifiedInputs = new uint256[](6);
            for (uint256 j = 0; j < 6; j++) {
                modifiedInputs[j] = publicInputs[j];
            }
            modifiedInputs[i] = modifiedInputs[i] + 1;

            bool result = verifier.verifyRedemptionProof(REDEEM_PROOF, modifiedInputs);
            assertFalse(result, string.concat("Proof should fail with modified signal ", vm.toString(i)));
        }
    }

    /**
     * @notice Test that wrong proof length is rejected
     */
    function test_RedeemProofFailsWithWrongLength() public {
        uint256[] memory publicInputs = new uint256[](6);
        publicInputs[0] = REDEEM_COMMITMENT_OUT;
        publicInputs[1] = REDEEM_MERKLE_ROOT;
        publicInputs[2] = REDEEM_NULLIFIER;
        publicInputs[3] = REDEEM_AMOUNT;
        publicInputs[4] = REDEEM_TOKEN_ADDRESS;
        publicInputs[5] = REDEEM_RECIPIENT;

        // Test with truncated proof
        bytes memory shortProof = new bytes(100);
        vm.expectRevert();
        verifier.verifyRedemptionProof(shortProof, publicInputs);
    }

    /**
     * @notice Test that wrong number of public inputs is rejected
     */
    function test_RedeemProofFailsWithWrongInputCount() public {
        // Test with 5 inputs (too few)
        uint256[] memory fewInputs = new uint256[](5);
        fewInputs[0] = REDEEM_COMMITMENT_OUT;
        fewInputs[1] = REDEEM_MERKLE_ROOT;
        fewInputs[2] = REDEEM_NULLIFIER;
        fewInputs[3] = REDEEM_AMOUNT;
        fewInputs[4] = REDEEM_TOKEN_ADDRESS;

        vm.expectRevert();
        verifier.verifyRedemptionProof(REDEEM_PROOF, fewInputs);

        // Test with 7 inputs (too many)
        uint256[] memory manyInputs = new uint256[](7);
        manyInputs[0] = REDEEM_COMMITMENT_OUT;
        manyInputs[1] = REDEEM_MERKLE_ROOT;
        manyInputs[2] = REDEEM_NULLIFIER;
        manyInputs[3] = REDEEM_AMOUNT;
        manyInputs[4] = REDEEM_TOKEN_ADDRESS;
        manyInputs[5] = REDEEM_RECIPIENT;
        manyInputs[6] = 0;

        vm.expectRevert();
        verifier.verifyRedemptionProof(REDEEM_PROOF, manyInputs);
    }

    /**
     * @notice Test that public inputs >= SCALAR_FIELD are rejected
     */
    function test_RedeemProofFailsWithInputsOutOfField() public {
        uint256[] memory publicInputs = new uint256[](6);
        publicInputs[0] = SCALAR_FIELD; // Equal to field, should be rejected
        publicInputs[1] = REDEEM_MERKLE_ROOT;
        publicInputs[2] = REDEEM_NULLIFIER;
        publicInputs[3] = REDEEM_AMOUNT;
        publicInputs[4] = REDEEM_TOKEN_ADDRESS;
        publicInputs[5] = REDEEM_RECIPIENT;

        vm.expectRevert();
        verifier.verifyRedemptionProof(REDEEM_PROOF, publicInputs);
    }

    // =========================================================================
    // PARTIAL REDEEM PROOF TESTS
    // =========================================================================

    // Partial redeem proof data from fixture
    bytes constant PARTIAL_PROOF = hex"2fc42dcd7c5dd98c542c25420fc894bea827d9eb313469d96e9324c845dfe7992fcd9e98ad1dd8857c1693cb7d293803e10d80aa9333165ba27e47b3154a53f2198770fac4d99524e3802a30a9156f7c8c57ba8523e4eb13f6404483445947ae27f0c8ee236b758d6fd95e0a7c45b8e11e720b31a930c20b829e516f6dbac0c21add53f8ff10e07da40762cce0ddbeb7275fc1f387fc3dd968f557e9808f9fcb1dba28c857993b1eb857d1d56600a2b6d8ed4237ce17d41b1472a58341755ef6275fe8d0c13685e5319e772d20ff5233b0414afdff490f84bfbb27701af1b7e80c51ad972a0c271e8558b458f3660f7d24da768e3e0b1db807d3dd67cc68ae21";

    // Public signals for partial redeem (10 signals in snarkjs order: outputs first, then inputs)
    // Outputs: oldCommitmentOut, newCommitmentOut, remainingAmountOut
    // Inputs: merkleRoot, oldNullifier, redeemAmount, tokenAddress, recipient, originalAmount, newCommitment
    uint256 constant PARTIAL_OLD_COMMITMENT_OUT = 11933691137357034313034463957668677800502692913015302002547064940251915195941;
    uint256 constant PARTIAL_NEW_COMMITMENT_OUT = 6251788577075893111916281412272181319815081107879442665517928285755453593710;
    uint256 constant PARTIAL_REMAINING_AMOUNT_OUT = 700000000000000000; // 0.7 tokens
    uint256 constant PARTIAL_MERKLE_ROOT = 17510383558094335553464105738347865424959629711116782436878656566490521182141;
    uint256 constant PARTIAL_OLD_NULLIFIER = 16934634096852800990532761937123260000074042736039435791597953041384840663268;
    uint256 constant PARTIAL_REDEEM_AMOUNT = 300000000000000000; // 0.3 tokens
    uint256 constant PARTIAL_TOKEN_ADDRESS = 103929005307130220006098923584552504982110632081;
    uint256 constant PARTIAL_RECIPIENT = 642829559307850963015472508762062935916233390536;
    uint256 constant PARTIAL_ORIGINAL_AMOUNT = 1000000000000000000; // 1 token
    uint256 constant PARTIAL_NEW_COMMITMENT = 6251788577075893111916281412272181319815081107879442665517928285755453593710;

    /**
     * @notice Test that partial redeem public signals are within the scalar field
     */
    function test_PartialRedeemSignalsWithinField() public pure {
        assertLt(PARTIAL_OLD_COMMITMENT_OUT, SCALAR_FIELD, "oldCommitmentOut >= SCALAR_FIELD");
        assertLt(PARTIAL_NEW_COMMITMENT_OUT, SCALAR_FIELD, "newCommitmentOut >= SCALAR_FIELD");
        assertLt(PARTIAL_REMAINING_AMOUNT_OUT, SCALAR_FIELD, "remainingAmountOut >= SCALAR_FIELD");
        assertLt(PARTIAL_MERKLE_ROOT, SCALAR_FIELD, "merkleRoot >= SCALAR_FIELD");
        assertLt(PARTIAL_OLD_NULLIFIER, SCALAR_FIELD, "oldNullifier >= SCALAR_FIELD");
        assertLt(PARTIAL_REDEEM_AMOUNT, SCALAR_FIELD, "redeemAmount >= SCALAR_FIELD");
        assertLt(PARTIAL_TOKEN_ADDRESS, SCALAR_FIELD, "tokenAddress >= SCALAR_FIELD");
        assertLt(PARTIAL_RECIPIENT, SCALAR_FIELD, "recipient >= SCALAR_FIELD");
        assertLt(PARTIAL_ORIGINAL_AMOUNT, SCALAR_FIELD, "originalAmount >= SCALAR_FIELD");
        assertLt(PARTIAL_NEW_COMMITMENT, SCALAR_FIELD, "newCommitment >= SCALAR_FIELD");
    }

    /**
     * @notice Test that partial redeem proof has correct number of public signals (10)
     */
    function test_PartialRedeemPublicSignalCount() public pure {
        uint256[] memory signals = new uint256[](10);
        signals[0] = PARTIAL_OLD_COMMITMENT_OUT;
        signals[1] = PARTIAL_NEW_COMMITMENT_OUT;
        signals[2] = PARTIAL_REMAINING_AMOUNT_OUT;
        signals[3] = PARTIAL_MERKLE_ROOT;
        signals[4] = PARTIAL_OLD_NULLIFIER;
        signals[5] = PARTIAL_REDEEM_AMOUNT;
        signals[6] = PARTIAL_TOKEN_ADDRESS;
        signals[7] = PARTIAL_RECIPIENT;
        signals[8] = PARTIAL_ORIGINAL_AMOUNT;
        signals[9] = PARTIAL_NEW_COMMITMENT;

        assertEq(signals.length, 10, "Expected 10 public signals for partial redeem");
    }

    /**
     * @notice Test that real partial redeem Groth16 proof verifies successfully
     */
    function test_PartialRedeemProofVerification() public {
        uint256[] memory publicInputs = new uint256[](10);
        publicInputs[0] = PARTIAL_OLD_COMMITMENT_OUT;
        publicInputs[1] = PARTIAL_NEW_COMMITMENT_OUT;
        publicInputs[2] = PARTIAL_REMAINING_AMOUNT_OUT;
        publicInputs[3] = PARTIAL_MERKLE_ROOT;
        publicInputs[4] = PARTIAL_OLD_NULLIFIER;
        publicInputs[5] = PARTIAL_REDEEM_AMOUNT;
        publicInputs[6] = PARTIAL_TOKEN_ADDRESS;
        publicInputs[7] = PARTIAL_RECIPIENT;
        publicInputs[8] = PARTIAL_ORIGINAL_AMOUNT;
        publicInputs[9] = PARTIAL_NEW_COMMITMENT;

        console2.log("Testing partial redeem proof verification...");
        console2.log("  Proof length:", PARTIAL_PROOF.length);
        console2.log("  Public signals:", publicInputs.length);

        bool result = verifier.verifyPartialRedemptionProof(PARTIAL_PROOF, publicInputs);
        assertTrue(result, "Partial redeem proof verification failed");
    }

    /**
     * @notice Test that modifying any public signal causes partial verification to fail
     */
    function test_PartialRedeemProofFailsWithWrongSignals() public {
        uint256[] memory publicInputs = new uint256[](10);
        publicInputs[0] = PARTIAL_OLD_COMMITMENT_OUT;
        publicInputs[1] = PARTIAL_NEW_COMMITMENT_OUT;
        publicInputs[2] = PARTIAL_REMAINING_AMOUNT_OUT;
        publicInputs[3] = PARTIAL_MERKLE_ROOT;
        publicInputs[4] = PARTIAL_OLD_NULLIFIER;
        publicInputs[5] = PARTIAL_REDEEM_AMOUNT;
        publicInputs[6] = PARTIAL_TOKEN_ADDRESS;
        publicInputs[7] = PARTIAL_RECIPIENT;
        publicInputs[8] = PARTIAL_ORIGINAL_AMOUNT;
        publicInputs[9] = PARTIAL_NEW_COMMITMENT;

        // Verify original proof works
        assertTrue(verifier.verifyPartialRedemptionProof(PARTIAL_PROOF, publicInputs), "Original proof should verify");

        // Modify each signal and verify failure
        for (uint256 i = 0; i < 10; i++) {
            uint256[] memory modifiedInputs = new uint256[](10);
            for (uint256 j = 0; j < 10; j++) {
                modifiedInputs[j] = publicInputs[j];
            }
            modifiedInputs[i] = modifiedInputs[i] + 1;

            bool result = verifier.verifyPartialRedemptionProof(PARTIAL_PROOF, modifiedInputs);
            assertFalse(result, string.concat("Proof should fail with modified signal ", vm.toString(i)));
        }
    }

    /**
     * @notice Test that wrong number of public inputs for partial redeem is rejected
     */
    function test_PartialRedeemProofFailsWithWrongInputCount() public {
        // Test with 9 inputs (too few)
        uint256[] memory fewInputs = new uint256[](9);
        for (uint256 i = 0; i < 9; i++) {
            fewInputs[i] = i;
        }

        vm.expectRevert();
        verifier.verifyPartialRedemptionProof(PARTIAL_PROOF, fewInputs);

        // Test with 11 inputs (too many)
        uint256[] memory manyInputs = new uint256[](11);
        for (uint256 i = 0; i < 11; i++) {
            manyInputs[i] = i;
        }

        vm.expectRevert();
        verifier.verifyPartialRedemptionProof(PARTIAL_PROOF, manyInputs);
    }
}
